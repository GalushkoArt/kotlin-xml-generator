package art.galushko.kotlinXmlGenerator.generators

import art.galushko.kotlinXmlGenerator.ModelGenerator
import art.galushko.kotlinXmlGenerator.model.Tag
import art.galushko.kotlinXmlGenerator.model.TagBuilder
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.TypeVariableName
import com.squareup.kotlinpoet.asTypeName


const val NAMESPACE = "\$namespace"
val genericType = TypeVariableName("T")
val unitType = Unit::class.asTypeName()
val listType = List::class.asTypeName()
val stringType = String::class.asTypeName().copy(nullable = true)

class TagClassGenerator(
    private val parentGenerator: ModelGenerator,
    private val classTagName: String,
    private val tagDefinition: Map<String, Any>,
    private val packageName: String,
) {
    private val namespace = tagDefinition.getOrDefault(NAMESPACE, "") as String

    fun getFileSpec(): FileSpec = FileSpec.builder(packageName, getTagClassName(classTagName))
        .addType(generateTagClass())
        .build()

    private fun generateTagClass() = TypeSpec.classBuilder(ClassName(packageName, getTagClassName(classTagName)))
        .superclass(Tag::class)
        .addSuperclassConstructorParameter("%S", namespace)
        .addKdoc("This file was generated by %T\nYour changes will be lost", this::class.asTypeName())
        .addAnnotation(
            AnnotationSpec.builder(Suppress::class)
                .addMember("%S, %S", "RedundantVisibilityModifier", "PropertyName")
                .build()
        )
        .addProperties(generateProperties())
        .addType(generateBuilder())
        .addType(getDslGenerator().generateDslObject())
        .build()

    fun getBasePackage() = parentGenerator.basePackage

    fun getPackageOfAnonymousTag() = "${packageName}.$classTagName"

    private fun getDslGenerator() = DslGenerator(packageName, classTagName)

    private fun generateProperties(): Iterable<PropertySpec> = tagDefinition.filter { it.key != NAMESPACE && !it.key.startsWith('@') }
        .map { getPropertyGenerator(it.key, it.value).getProperty() }

    private fun getPropertyGenerator(name: String, definition: Any) = when (definition) {
        "String" -> StringPropertyGenerator(name)
        is String -> TagPropertyGenerator(name, definition, getBasePackage())
        is Map<*, *> -> {
            defineAnonymousClass(name, definition)
            TagPropertyGenerator(name, name, getPackageOfAnonymousTag())
        }

        is List<*> -> {
            when (definition.first()) {
                is String -> ListPropertyGenerator(this, name, definition.first()!!)
                is Map<*, *> -> ListPropertyGenerator(this, name, defineAnonymousClass(name, definition.first() as Map<*, *>))
                else -> throw IllegalArgumentException("${definition.first()} is not allowed type for List! Allowed types are 'String', TagName, Map")
            }
        }

        else -> throw IllegalArgumentException("$definition is not allowed type for Tag! Allowed types are 'String', TagName, Map, List")
    }

    private fun defineAnonymousClass(name: String, definition: Map<*, *>): Map<String, Any> {
        val mapDefinition = (definition as Map<String, Any>).toMutableMap()
        mapDefinition.putIfAbsent(NAMESPACE, namespace)
        parentGenerator.defineTag(name, mapDefinition, getPackageOfAnonymousTag())
        return mapDefinition
    }

    private fun generateBuilder() = TypeSpec.classBuilder(getTagBuilderName(classTagName))
        .primaryConstructor(
            FunSpec.constructorBuilder()
                .addParameter("tag", ClassName(packageName, getTagClassName(classTagName)))
                .build()
        )
        .addProperty(
            PropertySpec.builder("tag", ClassName(packageName, getTagClassName(classTagName)))
                .initializer("tag")
                .addModifiers(KModifier.OVERRIDE)
                .build()
        )
        .addAnnotation(
            AnnotationSpec.builder(Suppress::class)
                .addMember("%S, %S", "TestFunctionName", "MoveLambdaOutsideParentheses")
                .build()
        )
        .superclass(TagBuilder::class)
        .addSuperclassConstructorParameter("tag")
        .addFunctions(generateBuilderFunctions())
        .build()

    private fun generateBuilderFunctions() = tagDefinition.filter { it.key != NAMESPACE }
        .map {
            if (it.key.contains('@')) AttributeGenerator(it.key.removePrefix("@")) else getPropertyGenerator(it.key, it.value)
        }.flatMap { it.builderFunction() }


    companion object {
        fun getTagClassName(tag: String) = "${tag}Tag"
        fun getTagBuilderName(tag: String) = "${tag}Builder"
    }
}